////////////////////////////////////////////////////////////////////
/// \class dataReader
///
/// \brief  Reading data from a input ROOT tree generated from MC onto
///         a 2D array of parameter theta and phi.
///
/// \author Aobo Li <liaobo77@bu.edu>
/// \contact  Aobo Li <liaobo77@bu.edu>
///
/// REVISION HISTORY:\n
///    25 Feburary 2018 : Aobo Li - first version
///
///
///  \details  First Version of MC data reader for the Machine Learning
///            study. It takes the data generated by MC, calculating its
///            theta and phi coordinates in spherical coordinate system, then
///            assign each photon hit to its corresponding "PMT grid".
///
////////////////////////////////////////////////////////////////////
#include "TSystem.h"
#include "TChain.h"
#include "TFile.h"
#include "TClonesArray.h"
#include "TTree.h"
#include "TH1.h"
#include "TH2.h"
#include "TCanvas.h"
#include "TImage.h"
#include "TTreeReader.h"
#include "TTreeReaderValue.h"
#include "TTreeReaderArray.h"
#include <algorithm>
#include <vector>

using namespace std;
using namespace TMath
void dataReader(TString fileName, int nPMTs = 5000) {

  //Constructing "PMT Grid" as a 2D vector, with one axis theta and the axis phi.
  //This is a relatively stupid approach, we should discuss about better approach later.
  //Ultimately we will want to use this grid as an approximation of PMT locations on
  //real detector.
  static const int thetaDimension = static_cast<int>(sqrt(nPMTs/2));//Theta: 0 to Pi
  static const int phiDimension = 2 * thetaDimension;//Phi: 0 to 2 Pi
  std::vector<std::vector<int>> fPMTGrid(thetaDimension,std::vector<int>(phiDimension, 0));

  TFile *treeFile = new TFile(fileName);
  TTreeReader tr("epgTree", treeFile);

  double r;
  double interval = TMath::Pi() / thetaDimension;
  double theta;
  double phi;
  int thetaIndex;
  int phiIndex;

  TTreeReaderValue<Int_t> NPhoton(tr, "N_phot");
  TTreeReaderArray<float> x(tr, "x_hit");
  TTreeReaderArray<float> y(tr, "y_hit");
  TTreeReaderArray<float> z(tr, "z_hit");
  TTreeReaderArray<float> t(tr, "PE_time");
  TTreeReaderArray<int> PECreation(tr, "PE_creation");
  TTreeReaderArray<int> Process(tr, "process");


  while (tr.Next()) {
    for(size_t iPhoton = 0; iPhoton < *NPhoton; ++iPhoton) {
      //Only read photons that generate PE
      if (PECreation[iPhoton] == 1) {
        //Read x,y,z coordinate
        double currentX = x[iPhoton];
        double currentY = y[iPhoton];
        double currentZ = z[iPhoton];

        //calculate r, should be the same for all photons.
        r = sqrt(TMath::Power(currentX,2) + TMath::Power(currentY,2) + TMath::Power(currentZ,2));

        //calculate theta and phi
        theta = TMath::ACos(currentZ/ r);
        phi = TMath::ATan2(currentY, currentX) + TMath::Pi();

        //Assign each theta and phi to it's grid location.
        thetaIndex = static_cast<int>(theta / interval);
        phiIndex = static_cast<int>(phi / interval);

        //Adding photon to the Grid, for now:
        //  If Cherenkov photon, add 1
        //  If Scintillation photon, add 0(aborting all scintillation photons)
        //But ultimately we don't want to rely on this.
        fPMTGrid[thetaIndex][phiIndex] += Process[iPhoton];
      }
    }
   }

}
